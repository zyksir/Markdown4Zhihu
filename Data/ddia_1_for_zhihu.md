## 数据密集型应用设计(DDIA)阅读笔记(1)

ddia中文翻译网址：https://github.com/Vonng/ddia

**加粗的小标题我觉得章节讨论的点**

普通的文字是内容的总结

> 灰灰的是我个人的一些想法+吐槽

### 第一章 可靠性，可伸缩性，可维护性 

第一章探讨的核心问题：设计一个数据密集型应用需要从哪几个角度开始讨论问题

##### 数据密集型应用是什么

这是相对于计算密集型应用而言的一个概念，CPU 并不是这类应用的瓶颈，数据量、数据复杂性、数据变更速度才是。e.g 数据库、缓存、索引、批处理、流处理

##### 可靠性是什么

- 总得来说，要求系统面对各种故障的时候仍能正常工作

- 正常工作指的是 *完成预期功能且达到预期性能水平*，二者缺一不可。

- 下面列举一些常见故障：

  - 硬件故障，例如机房断电、硬盘崩溃。常用解决方式：硬件冗余(准备备用硬件，例如备用机器、柴油发电机)、软件容错(系统允许一台机器重启而整个服务不崩)
  - 软件故障，例如程序中各种小 bug。常用解决方式：自动化、全方位测试；监控进程行为；进程隔离等等
  - 人为错误，例如配置参数的时候配错了。常用解决方式：优秀的文档；优秀的抽象和 API；允许简单、快速的恢复(也就是回滚)

  > 1. 这里提到谷歌一个有(xuan)趣(fu)的研究：硬盘的平均无故障时间是10~50年。
  >
  > 2. 当我们提到监控行为的时候，就应该思考一下监控哪些行为。我认为整体的思路就是从功能和性能上出发去看。
  > 3. 永远不要相信任何人写的代码就一定是对的。永远不要觉得只改一个小地方就不会出错。只有通过了测试才能放心。

##### 什么是可伸缩性

- 系统应对负载增长的能力。换句话说，如果负载增加，如何增加较少的计算资源来满足需求？

- 如何描述负载：QPS，KPS，cache 的命中率，活跃用户等。
  - 常见的应对负载增加的办法：扩容。包括水平扩容(换成一台更强大的机器)和横向扩容(分布到多台机器中去)

> 假如扩容就可以了，那么程序员就没饭吃了 orz。这里补充了推特的一个例子，如何实现 发文-读取这个操作。一开始发文就是往数据库写入(代价小)，读取时就是查询关注者发文(代价大)；但是由于发文频率远低于读取频率(推特的例子中，读是300k/s，写是4.6k/s)，因此考虑每个用户维护一个读的 cache，发文的时候往所有粉丝的 cache 去写。当然对那种粉丝很多的明星可以用老办法来保证他们发文之后的延迟不会很高。这样下来相同机器的负载就上去了，这才是程序员该干的事情。

- 如何描述性能：吞吐，延迟，响应时间(网络延迟+服务延迟)；除了平均值还会用百分位点(例如 p99，高百分位点叫尾部延迟)

> 这里提到头部阻塞是尾部延迟的一大部分，后面的请求要等前面的请求完成才能继续

- 在设计系统的时候要围绕着各种假设，例如思考是 QPS 大，每个请求比较小 还是 QPS 比较小，每个请求非常大？哪些操作是罕见的哪些是常见的？我是实现这个功能就够了还是要为后续迭代做足够的准备？类似天底下没有免费的午餐，架构这里也没有一个万金油架构可以适配所有的场景，只有做出合理的假设才能做好一个架构。

##### 什么是可维护性

主要包括以下三个方面

- 可操作性：一个团队要能监控服务运行状况、追踪问题原因并修复各种问题、及时更新软件；为此，监控工具、自动化工具、文档等极为重要。

- 简单性：使用抽象，将细节隐藏于一个简单易懂的外观下。同时尽可能地解耦各个模块。

- 可演化性：可以支持变化的需求。



### 第二章 数据模型与查询语言

第二章解决的核心问题：不同数据模型之间的特点

- 为什么已经有 SQL 了我们还需要其他数据模型
  - 随着数据量地增大，我们需要更大地数据集或者更高地吞吐
  - 渴望跳出关系数据库模式的限制，想要一个更自由的数据模型
  - SQL 存在对象关系不匹配的问题。也就是存储在关系表中的数据和程序代码中的数据是需要转化的。

- 几种模型的比较：
  - 关系数据库：一个表就是元组的集合。它的数据模式在写的时候就被确定
    - 优势：更好的支持一对多和多对多关系
  - 文档数据库： JSON、XML。它的数据模式在写的时候还不被确定，在读的时候才会确定。
    - 优势：由于其局部性拥有更好的性能
    - 局限性：就算只修改/查询文档的一小部分也要重写/读取整个文档，因此建议保持小文档
  - 图数据库：顶点和边组成的图	
    - 存储模式：就如同图一样，可以用三元组(顶点，边，顶点)存储；也可以用两个表表示，一个存储顶点(属性、入边集合、出边集合、node_id)，一个存储边(属性、起点、终点、关系类型、edge_id)。前者称之为三元组模型，后者称之为属性图模型
    - 顶点和边都有 id，可以快速索引；
    - 适用于关联度很高的数据

> NoSQL -> Not Only SQL。SQL 还是很重要很有用的。另外，目前文档数据库和关系数据库正在融合，关系数据库已经支持 XML 和 JSON；文档数据库也在逐渐支持连接

- 几种查询语言：
  - 命令式查询：类似 C 代码，用循环&if 等，可以控制每一步怎么做
  - 声明式查询：严格遵循关系代数，例如SQL
  - MapReduce 查询：介于命令式和声明式之间，使用 map 操作和 reduce 操作
  - Cypher查询：专为属性图模型设计
  - SPARQL查询：转为三元组模型设计

